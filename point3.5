# First Architecture Project: Medical Test Management System
# Done by students --> Name: Sondos Farrah ID: 1200905
#                  --> Name: Mohammad Makhamreh ID: 1200227
#
# INSTRUCTOR AND SECTION
# INSTRUCTOR NAME: Dr.Aziz Qaroush
# SECTION NO.: 2

################ Data Section ################
.data
#file_name:          .asciiz "C:\\Users\\HP\\Desktop\\test.txt"
#file_nameO:          .asciiz "C:\\Users\\HP\\Desktop\\out.txt"
file_name:          .asciiz "C:\\Users\\LENOVO\\Desktop\\cse\\cse4.2\\Arch\\project1\\test.txt"
file_nameO:          .asciiz "C:\\Users\\LENOVO\\Desktop\\cse\\cse4.2\\Arch\\project1\\out.txt"
# to make the program run properly, the path must be the path of the test.txt file

#-----------------------Menu Choices Messages----------------------------
welcomeMSG:         .asciiz "\n\t\t~Welcome To the Medical Test Management System program~\t\t\n"
menu:               .asciiz "\t Please enter your choice:\n"
addMedicalTest:     .asciiz "\t 1. Add a new medical test.\n"
searchByPatientID:  .asciiz "\t 2. Search for a test by patient ID\n"
retrieveAllTests:   .asciiz "\t\t1. Retrieve all patient tests\n"
retrieveNormalTests: .asciiz "\t\t2. Retrieve all up normal patient tests\n"
retrieveSpecificPeriod: .asciiz "\t\t3. Retrieve all patient tests in a given specific period\n"
searchForUnnormalTests: .asciiz "\t 3. Search for unnormal tests.\n"
averageTestValue:   .asciiz "\t 4. Average test value\n"
updateAnExistingTestResult: .asciiz "\t 5.Update an existing test result\n"
deleteATest:        .asciiz "\t 6. Delete a test\n"
invalidInputMsg:    .asciiz "\t Invalid input. Please try again.\n"
enterPatientIDMsg:  .asciiz "\t Enter Patient ID (7 digits): "
enterTestNameMsg:   .asciiz "\t Enter Test name: "
enterTestDateMsg:   .asciiz "\t Enter Test date (YYYY-MM): "
enterTestResultMsg: .asciiz "\t Enter Test result: "
confirmationMsg:    .asciiz "\nMedical test information entered:\n"
LDL: .asciiz "LDL"
BPT: .asciiz "BPT"
Hgb: .asciiz "Hgb"
BGT: .asciiz "BGT"
testNameBuffer:   .space 4    # Buffer to store Test name
testDateBuffer:   .space 8   # Buffer to store Test date (YYYY-MM)
buffer:             .space 10000 # Buffer to store the contents of the file
testIDBuffer:         .space 7# Define a label at the end of the buffer section
testResultBuffer1: .space 7
testResultBuffer2: .space 7
#testResultBufferDec:         .space 8
#testResultBufferFrac:         .space 8
comma: .asciiz ", " 
colon: .asciiz ": "
point: .asciiz "."
HgbMin: .float 13.8
HgbMax: .float 17.2
BGTMin: .float 70.0
BGTMax: .float 99.0
LDLMin: .float 0.0
LDLMax: .float 100.0
BPTMin: .float 0.0
BPTMaxS: .float 120.0
BPTMaxD: .float 80.0
f35: .float 0.35

integerPart: .word 0       # Space for the integer part
fractionalPart: .word 0    # Space for the fractional part as an integer
scale: .word 1             # Scale for the fractional part (10^n)
MSG1: .asciiz "Converted Float: "
resultCutbuffer: .space 32  # Allocate space for the buffer to store the extracted bytes


#---------------------End of Choices Message -----------------------------

################ Code Section ################
.text
.globl main

main:
    # Print welcome message
    li $v0, 4
    la $a0, welcomeMSG
    syscall

   
    jal readFile
    # Print the contents of the file
    li $v0, 4
    la $a0, buffer
    syscall

    # Close the file
    li $v0, 16
    move $a0, $s0
    syscall

    # Print the menu
    li $v0, 4
    la $a0, menu
    syscall

    # Print the menu choices
    li $v0, 4
    la $a0, addMedicalTest
    syscall
    li $v0, 4
    la $a0, searchByPatientID
    syscall
    li $v0, 4
    la $a0, searchForUnnormalTests
    syscall
    li $v0, 4
    la $a0, averageTestValue
    syscall
    li $v0, 4
    la $a0, updateAnExistingTestResult
    syscall
    li $v0, 4
    la $a0, deleteATest
    syscall

    # Get user's choice
    li $v0, 5
    syscall
    move $s1, $v0 # Save the user's choice

    # Check if user chose to add a new medical test
    li $t0, 1
    beq $s1, $t0, addNewMedicalTest
    # Check if user chose to Search for a test by patient ID
    li $t0,2
    beq $s1,$t0,searchByID

exit:    
    # Exit the program
    li $v0, 10
    syscall
#----------------Read File Function - -------------------------#
readFile:
 # Open the file
    li $v0, 13
    la $a0, file_name
    li $a1, 0
    li $a2, 0
    syscall
    move $s0, $v0  # Save the file descriptor

    # Read and print the contents of the file
    li $v0, 14
    move $a0, $s0
    la $a1, buffer
    li $a2, 2000
    syscall
    jr $ra
#-----------------------------------------------------------option1---------------------------------------------------------------------------------------
addNewMedicalTest:
    # Print prompts and get input data
    #-------------------read ID---------------------------------
readID:
    li $v0, 4
    la $a0, enterPatientIDMsg
    syscall
    li $v0, 5 #read int
    syscall
    move $s2, $v0  # Save Patient ID
    move $t7 , $s2
    move $a0,$s2
    la $a1,testIDBuffer
    jal intToString
    #validate id is 7digits integer
    move $t0, $t7 
    li $t1, 0 # Counter for the number of divisions
validateID:
    div $t0, $t0, 10  # Divide $t0 by 10
    addi $t1, $t1, 1  # Increment the counter
    beqz $t0, checkID
    j validateID  
checkID:
    beq $t1, 7, is7digits
not7digits:
    li $v0,4
    la $a0,invalidInputMsg
    syscall
    j readID
    #convert int to string-----
intToString:
        sw $ra,($sp)
	sub $sp,$sp,4
	
	li $t1,10
	move $s2, $a0
	move $t4, $a1		
	
divLoop:
	div $s2, $t1
	mfhi $t3
	mflo $s2
	add $t3,$t3,48
	sb $t3,($t4)
	add $t4, $t4, 1
	bne $s2, $zero, divLoop
	
	
	move $t0,$a1
	jal getLengthStr
	
	move $t0,$a1
	move $t4,$a1
	
	add $t4, $t4 , $t3

	sub $t4, $t4,1
	
	div $t3,$t3,2
	
	li $t1,0 	#reset to 0
	
reverseLoop:
	
	lb $t2,($t0)
	lb $t5,($t4)
	
	sb $t5,($t0)
	sb $t2,($t4) 
	
	add $t1, $t1, 1
	
	sub $t4, $t4, 1
	add $t0, $t0, 1
	
	blt $t1,$t3,reverseLoop
	
	add $sp,$sp,4
	lw $ra,($sp)
	jr $ra
	
	
.globl getLengthStr
getLengthStr:
	sw $ra,($sp)
	sub $sp,$sp,4
	
	li $t3,0
	
loop:
		lb $t2,($t0)
		add $t0,$t0,1
		
		beq $t2,' ',Detect
		add $t3,$t3,1			 		 
	  
Condt:
	  bne $t2,'\0',loop 
	
	  j end
	  
Detect:
	  	j Condt
	  
end:
	  
	  sub $t3, $t3, 1
	  
	  add $sp,$sp,4
	  lw $ra,($sp)
	  jr $ra
is7digits:
    #-------------------read test name --------------------------------
readTName:
    li $v0, 4
    la $a0, enterTestNameMsg
    syscall
    # Assuming test name is limited to 3 characters
    li $v0, 8 #read string
    la $a0, testNameBuffer
    li $a1, 4
    syscall
    #move $s3, $v0  # Save Test name
    # Compare the input string with LDL
    la $a0, testNameBuffer
    la $a1, LDL
    jal strcmp
    beqz $v0, matched
    # Compare the input string with BPT
    la $a0, testNameBuffer
    la $a1, BPT
    jal strcmp
    beqz $v0, matchedBPT
    # Compare the input string with Hgb
    la $a0, testNameBuffer
    la $a1, Hgb
    jal strcmp
    beqz $v0, matched
    # Compare the input string with BGT
    la $a0, testNameBuffer 
    la $a1, BGT
    jal strcmp
    beqz $v0, matched
    b unmatched
strcmp:
validateName:
        lb $t0, 0($a0)   # load a byte from string1
        lb $t1, 0($a1)   # load a byte from string2
        beqz $t0, check_end   # if string1 is finished, check if string2 is also finished
        beqz $t1, not_equal   # if string2 is finished, strings are not equal
        bne $t0, $t1, not_equal   # if characters are not equal, strings are not equal
        addi $a0, $a0, 1   # move to the next character in string1
        addi $a1, $a1, 1   # move to the next character in string2
        j validateName

    check_end:
        beqz $t1, equal   # if string2 is also finished, strings are equal
        j not_equal

    equal:
        li $v0, 0   # strings are equal
        jr $ra

    not_equal:
        li $v0, 1   # strings are not equal
        jr $ra
matchedBPT:
    li $t9,1
matched:
    #-------------------read test date --------------------------------
readTDate:
    li $v0, 4
    la $a0, enterTestDateMsg
    syscall
    # Assuming test date is in format YYYY-MM
    li $v0, 8
    la $a0, testDateBuffer
    li $a1, 8
    syscall
    #move $s4, $v0  # Save Test date
validateDate:
    # Check if the month part is valid (from 1 to 12)
checkFormat:
    lb $t2, 4($a0)         # Check if the 5th character is '-'
    li $t3, '-'            # ASCII code for '-'
    bne $t2, $t3, notInFromat
    
    lb $t0, 5($a0)  
checkTen:
    lb $t0, 5($a0) 
    li $t1,'0'
    beq $t0,$t1 , zeroTens
    #oneTens
    lb $t0, 5($a0) 
    beq $t0,'1',oneTens  
    b notInFromat
zeroTens:
    lb $t0, 6($a0) 
    ble $t0, '9', lessThan9
    b notInFromat
lessThan9:
    lb $t0, 6($a0)
    bge $t0, '1', readResult
    b notInFromat
oneTens:
    lb $t0, 6($a0)
    beq $t0,'1' , readResult
    #oneTens
    lb $t0, 6($a0)
    beq $t0,'2',readResult  
    b notInFromat
      
readResult:
    #-------------------read test result -------------------------------- 
    li $v0, 4
    la $a0, enterTestResultMsg
    syscall
    # read result as string
    li $v0, 8
    la $a0, testResultBuffer1
    li $a1, 6
    syscall
    beq $t9,1,readR2
    b saveToFile
readR2:
    # read result as string
    li $v0, 4
    la $a0, enterTestResultMsg
    syscall
    li $v0, 8
    la $a0, testResultBuffer2
    li $a1, 6
    syscall
    b saveToFile
notInFromat:
    li $v0,4
    la $a0,invalidInputMsg
    syscall
    j readTDate
unmatched:
    li $v0,4
    la $a0,invalidInputMsg
    syscall
    j readTName
saveToFile:
 # Calculate the length of the buffer
    # Initialize counter
li $t0, 0             # Counter for length
la $t1, buffer        # Load address of the buffer

# calculate the buffer length.
calculateLength:
    lb $t2, ($t1)      # Load a byte from the buffer
    beqz $t2, done     # If null terminator is found, exit loop
    addi $t0, $t0, 1   # Increment counter for length
    addi $t1, $t1, 1   # Move to the next byte in the buffer
    j calculateLength  # Repeat loop
# calculate the result1 length.
calculateLength2:
    lb $t2, ($t1)      # Load a byte from the buffer
    beqz $t2, done2     # If null terminator is found, exit loop
    addi $t0, $t0, 1   # Increment counter for length
    addi $t1, $t1, 1   # Move to the next byte in the buffer
    j calculateLength2  # Repeat loop
# calculate the result2 length.
calculateLength3:
    lb $t2, ($t1)      # Load a byte from the buffer
    beqz $t2, done3     # If null terminator is found, exit loop
    addi $t0, $t0, 1   # Increment counter for length
    addi $t1, $t1, 1   # Move to the next byte in the buffer
    j calculateLength3  # Repeat loop

done:
# At this point, $t0 contains the length of the string stored in the buffer

        #open file 
    	li $v0,13           	# open_file syscall code = 13
    	la $a0,file_name     	# get the file name
    	li $a1,1           	# file flag = write (1)
    	syscall
    	move $s1,$v0        	# save the file descriptor. $s0 = file
    	
    # Write buffer to the file
    li $v0, 15           # write_file syscall code = 15
    move $a0, $s1        # file descriptor
    la $a1, buffer       # the string that will be written
    move $a2, $t0        # length of the toWrite string (without null terminator)
    syscall
    	
    	#Write ID to the file
    	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,testIDBuffer	# the string that will be written
    	la $a2,7		# length of the toWrite string
    	syscall
    	#Write ':' to the file
    	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,colon	# the string that will be written
    	la $a2,2		# length of the toWrite string
    	syscall
    	#Write name to the file
    	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,testNameBuffer	# the string that will be written
    	la $a2,3		# length of the toWrite string
    	syscall
    	#Write ',' to the file
    	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,comma	# the string that will be written
    	la $a2,2		# length of the toWrite string
    	syscall
    	#Write date to the file
    	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,testDateBuffer	# the string that will be written
    	la $a2,7		# length of the toWrite string
    	syscall
    	#Write comma to the file
    	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,comma	# the string that will be written
    	la $a2,2		# length of the toWrite string
    	syscall
    	#Write result to the file
    	li $t0, 0             # Counter for length
	la $t1, testResultBuffer1        # Load address of the buffer
    	j calculateLength2
done2:
        	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,testResultBuffer1	# the string that will be written
	move $a2, $t0        # length of the toWrite string (without null terminator)		# length of the toWrite string
    	syscall
    	bne $t9,1, closeFile
	#Write ',' to the file
    	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,comma	# the string that will be written
    	la $a2,2		# length of the toWrite string
    	syscall
       #Write result to the file
        li $t0, 0             # Counter for length
	la $t1, testResultBuffer2        # Load address of the buffer
        j calculateLength3
done3:
    	li $v0,15		# write_file syscall code = 15
    	move $a0,$s1		# file descriptor
    	la $a1,testResultBuffer2	# the string that will be written
        move $a2, $t0        # length of the toWrite string (without null terminator)	
    	syscall  
closeFile:	
	#MUST CLOSE FILE IN ORDER TO UPDATE THE FILE
    	li $v0,16         		# close_file syscall code
    	move $a0,$s1      		# file descriptor to close
    	syscall
    	jal readFile
    	b exit
#-----------------------------------------------------------option2----------------------------------------------------------------------------------------
searchByID:
    li $v0, 4
    la $a0, enterPatientIDMsg
    syscall
    li $v0, 5 #read int
    syscall
    move $s2, $v0
    move $a0,$s2
    la $a1,testIDBuffer
    jal intToString
    li $v0, 4
    la $a0, retrieveAllTests
    syscall
    li $v0, 4
    la $a0, retrieveNormalTests
    syscall
    li $v0, 4
    la $a0, retrieveSpecificPeriod
    syscall
    #Check if user chose to Retrieve all patient tests
    li $v0, 5 #read int
    syscall
    move $s1, $v0
    li $t0,1
    beq $s1,$t0,allPTests    
     li $t0,2
    beq $s1,$t0,allUpnormalTests 
allPTests:
    # Load address of buffer into register $a1
    la $a1, buffer

r1:
   #li $v0,1
   #li $a0, 9
   #syscall
    # Load initial index (offset) of buffer into register $t0
    li $t0, 0
        # Load address of ID into register $a3
    la $a3, testIDBuffer
read7bytes:
    # Load byte from buffer at index $t0 into register $t1
    lb $t1, 0($a1) #buffer
    lb $t2,0($a3) #input ID
    bne $t1,$t2, newLine
    # Increment index
    addi $t0, $t0, 1
    # Increment buffer pointer
    addi $a1, $a1, 1 #inc off buffer
    addi $a3, $a3, 1 #inc off ID
    beq $t0,7 , printLine
    b read7bytes
    #b newLine
    # Repeat loop
newLine:
    lb $t1, 0($a1)
    beq $t1, '\n', r2
    beq $t1,'\0',exit
    addi $a1, $a1, 1 
    j    newLine
printLine:
    li $t7, 7
    sub $a1,$a1,$t7 
printLineS:
    lb $t1, 0($a1)
    beq $t1, '\n', r3
    beq $t1,'\0',exit
    addi $a1, $a1, 1 
    # Print ID
    li $v0, 11        # Print the character
    move $a0, $t1     # Move the character to $a0
    syscall
    j printLineS
    
r3:
    li $v0,11
    li $a0,10
    syscall
r2:    
    li $t7,1
    add $a1,$a1,$t7
    
    b r1

allUpnormalTests:
# Load address of buffer into register $a1
    la $a1, buffer

r11:
    # Load initial index (offset) of buffer into register $t0
    li $t0, 0
        # Load address of ID into register $a3
    la $a3, testIDBuffer
read7bytes1:
    # Load byte from buffer at index $t0 into register $t1
    lb $t1, 0($a1) #buffer
    lb $t2,0($a3) #input ID
    bne $t1,$t2, newLine1
    # Increment index
    addi $t0, $t0, 1
    # Increment buffer pointer
    addi $a1, $a1, 1 #inc off buffer
    addi $a3, $a3, 1 #inc off ID
    beq $t0,7 , testType
    b read7bytes1
    #b newLine
    # Repeat loop
newLine1:
    lb $t1, 0($a1)
    beq $t1, '\n', r22
    beq $t1,'\0',exit
    addi $a1, $a1, 1 
    j    newLine1
r22:    
    li $t7,1
    add $a1,$a1,$t7
    b r11       
testType:
    addi $a1,$a1,4 ## maybe we need to increment it by 1.------------------------------------------------------
    
    #lb $t2,'g'

    lb $t1,0($a1)
    beq $t1,'g',testIsHgb
    #beq $t1,$t2,testIsBPT
   #beq $t1,$t2,testIsBGT
   
    li $v0,11
    move $a0,$t1
    syscall 
    beq $t1,'L',testIsLDL
        
 #------------------------------Hgb------------------------------------------------------ 
testIsHgb:
	#min 13.8 max 17.2
	jal resultString
	jal stringToFloat	
	#f1 contains the result as float.    
checkMinHgb:
	l.s $f2, HgbMin
	c.lt.s $f2, $f1          # Compare $f2 with $f1 (set less than flag)
	bc1f   r22       # Branch if $f2 < $f1 to checkMaxHgb label
	b checkMaxHgb                    # Branch to new line label

checkMaxHgb: 
       
    	l.s $f2, HgbMax
   	c.le.s $f1, $f2          # Compare $f1 with $f2 (set less than or equal flag)
  	bc1f r22  # Branch if $f1 <= $f2 to printUpnormalTest label
   	b printUpnormalTest 
#------------------------------Hgb END------------------------------------------------------    

#------------------------------LDL ------------------------------------------- 	   
testIsLDL:
	#min 0 max 100
	li $v0,4
	la $a0,LDL
	syscall 
	jal resultString
	jal stringToFloat	
	#f1 contains the result as float.
checkMaxLDL: 
       
    	l.s $f2, LDLMax
   	c.lt.s $f1, $f2          # Compare $f1 with $f2 (set less than or equal flag)
  	bc1f r22  # Branch if $f1 < $f2 to printUpnormalTest label
   	b printUpnormalTest
   	       
printUpnormalTest:              
	#li $v0,11
	#li $a0,'S'
	#syscall 
	#b exit 
    li $v0,11
    li $a0,10 #printnewLine
    syscall             
	jal calculateFloatLength
 	sub $a1,$a1,$t0 #a1 now is the first digit in the float number
 	subi $a1,$a1,23 #a1 now the first char in the line(test)
printUpNormalLine:
 	lb $t1, 0($a1)
 	beq $t1, '\n',r33 
 	beq $t1,'\0',exit
	addi $a1, $a1, 1
	#print line
	li $v0, 11        # Print the character
	move $a0, $t1     # Move the character to $a0
	syscall
	j printUpNormalLine
	#la $t1, ($s0)        # Load address of the buffer
r33:
    li $v0,11
    li $a0,10 #printnewLine
    syscall
r222:    
    li $t7,1
    add $a1,$a1,$t7
    b r11

resultString:
   move $s6,$ra
# Load the start index of the bytes to read (22nd byte) into $t0
    addi $a1,$a1,12
    #li $t0, 23

    # Call function to read bytes from the line and store in buffer
    jal readBytes

    # Print the result
    li $v0, 4       # syscall code for printing string
    la $a0, resultCutbuffer  # load address of buffer into $a0
    syscall
    move $ra,$s6
    jr $ra
  

# Subroutine to read specific bytes from the line and store in buffer
readBytes:
    # Initialize variables
    la $t2, resultCutbuffer  # $t2 will hold the address of resultCutbuffer
   

looop:
    # Load a byte from the line
    lb $t3, 0($a1)

    # Check if the byte is newline character or null terminator
    beq $t3, '\n', done_reading
    beqz $t3, done_reading

    # Store the byte in the buffer
    sb $t3, 0($t2)

    # Move to the next byte in the line and buffer
    addi $a1, $a1, 1
    addi $t2, $t2, 1

    # Repeat until newline character or null terminator is encountered
    j looop

done_reading:
    # Null-terminate the buffer
    sb $zero, 0($t2)

    jr $ra          # Return to main
    
# calculate the result2 length.
calculateFloatLength:
    move $s6,$ra
    li $t0, 0       # Counter for length
    la $t1, resultCutbuffer   # Load address of the buffer
startCount:
    lb $t2, 0($t1)   # Load a byte from the buffer
    beqz $t2, done4  # If null terminator is found, exit loop
    addi $t0, $t0, 1 # Increment counter for length
    addi $t1, $t1, 1 # Move to the next byte in the buffer
    j startCount     # Repeat loop
done4:
    #subi $t0,$t0,1
    move $ra,$s6
    jr $ra
    
stringToFloat:
    move $s6,$ra
 # Parse the string and convert it to integer and fractional parts
    la $a0,resultCutbuffer            # Load address of the string
    jal parseString        # Jump to the string parsing function

    # The values are now stored in integerPart and fractionalPart
    
    # Convert integer and fractional parts to floating point and print
    jal convertPartsToFloatAndPrint

    # Exit the program
    li $v0, 10             # syscall number for exit
    syscall

# String parsing function that fills integerPart and fractionalPart
parseString:
    # Initialize variables
    li $t1, 0              # Will hold the integer part
    li $t2, 0              # Will hold the fractional part
    li $t3, 1              # Will be used for the scale
    li $t4,0               #will hold the number of int digit
    
    # Parse the integer part
parseInteger:
    beq $t0,'\n',endInteger
    addi $t4,$t4,1
    lb $t0, 0($a0)         # Load the next byte (character) from the string
    beq $t0, '.', endInteger # Check for decimal point
    beq $t0,'\0',endInteger
    beq $t0,' ',endInteger
back:
    sub $t0, $t0, '0'      # Convert from ASCII to integer
    mul $t1, $t1, 10       # Multiply current result by 10
    add $t1, $t1, $t0      # Add the new digit
    
    addiu $a0, $a0, 1      # Move to the next character
    j parseInteger         # Loop back

endInteger:
    sw $t1, integerPart    # Store the integer part
    addiu $a0, $a0, 1      # Move past the decimal point

    # Parse the fractional part
parseFractional:

    lb $t0, 0($a0)         # Load the next byte (character)
    beq $t0, '\0', endFractional # Check for null terminator
    
    sub $t0, $t0, '0'      # Convert from ASCII to integer
    mul $t2, $t2, 10       # Multiply current result by 10
    add $t2, $t2, $t0      # Add the new digit
    mul $t3, $t3, 10       # Increase scale
    addiu $a0, $a0, 1      # Move to the next character
    j parseFractional      # Loop back

endFractional:
    sw $t2, fractionalPart # Store the fractional part
    sw $t3, scale          # Store the scale
    jr $ra                 # Return

# Function to convert the parts to floating point and print
convertPartsToFloatAndPrint:
    # Load and convert integer part
    lw $s0, integerPart
    mtc1 $s0, $f1
    cvt.s.w $f1, $f1

    # Load and convert fractional part
    lw $s0, fractionalPart
    mtc1 $s0, $f2
    cvt.s.w $f2, $f2

    # Load and convert scale
    lw $s0, scale
    mtc1 $s0, $f3
    cvt.s.w $f3, $f3

    # Divide fractional part by scale
    div.s $f2, $f2, $f3

    # Combine integer and fractional parts
    add.s $f1, $f1, $f2

    # Print the message
    li $v0, 4
    la $a0, MSG1
    syscall

   #  Print the converted float
    
    mov.s $f12, $f1
    li $v0, 2
    syscall
    #b exit
    move $ra,$s6
    jr $ra                 # Return
    







